const { spawn, exec } = require('child_process');
const path = require('path');
const fs = require('fs-extra');
const { logger } = require('../utils/logger');

class OemerService {
  constructor() {
    this.pythonPath = process.env.PYTHON_PATH || 'python3';
    this.oemerPath = process.env.OEMER_PATH || 'oemer';
    this.maxMemory = process.env.OEMER_MAX_MEMORY || '4g';
    
    // Validate OEMER installation at startup
    this.validateInstallationAtStartup();
  }

  /**
   * Validate OEMER installation at service startup
   */
  async validateInstallationAtStartup() {
    try {
      await this.checkInstallation();
      logger.info('üéµ OEMER service initialized successfully - real processing available');
    } catch (error) {
      logger.error('‚ùå OEMER service initialization failed:', error.message);
      logger.warn('‚ö†Ô∏è  Sheet music processing will fail until OEMER is properly configured');
    }
  }

  /**
   * Check if Oemer is properly installed and configured
   */
  async checkInstallation() {
    try {
      logger.info('Checking Oemer installation...');

      // Test Python installation
      await this.executeCommand(`${this.pythonPath} --version`);

      // Test Oemer installation with correct API
      const testCommand = `${this.pythonPath} -c "from oemer.inference import inference; from oemer import build_system; print('Oemer available')"`;
      await this.executeCommand(testCommand);

      logger.info('‚úÖ Oemer installation verified');
      return true;
    } catch (error) {
      logger.error('‚ùå Oemer installation check failed:', error);
      throw new Error(`Oemer installation error: ${error.message}`);
    }
  }

  /**
   * Preprocess image to improve OMR recognition
   */
  async preprocessImage(imagePath, outputPath) {
    try {
      const sharp = require('sharp');

      const metadata = await sharp(imagePath).metadata();
      logger.info(`Original image: ${metadata.width}x${metadata.height}, ${metadata.density || 'unknown'} DPI`);

      // Enhance image for better OMR recognition
      await sharp(imagePath)
        .resize(Math.max(metadata.width * 2, 2000), null, {
          withoutEnlargement: false,
          kernel: sharp.kernel.lanczos3
        })
        .greyscale()
        .normalize()
        .sharpen({ sigma: 1, m1: 0.5, m2: 2 })
        .png({ quality: 100 })
        .toFile(outputPath);

      logger.info(`Preprocessed image saved to: ${outputPath}`);
      return outputPath;
    } catch (error) {
      logger.warn(`Image preprocessing failed, using original: ${error.message}`);
      return imagePath;
    }
  }

  /**
   * Process a sheet music image with Oemer OMR
   */
  async processImage(imagePath, outputDir) {
    logger.info(`Processing image with OEMER: ${imagePath}`);

    // Mandatory OEMER availability check - fail fast if not available
    try {
      await this.checkInstallation();
      logger.info('‚úÖ OEMER is available, proceeding with real OMR processing');
    } catch (installError) {
      logger.error('‚ùå OEMER is not available or not properly configured');
      throw new Error(`OEMER not available: ${installError.message}. Please ensure OEMER is properly installed in the Python environment.`);
    }

    // Process with real OEMER only - no fallbacks
    try {
      return await this.processWithOemer(imagePath, outputDir);
    } catch (error) {
      logger.error(`OEMER processing failed for ${imagePath}:`, error);
      throw new Error(`OEMER processing failed: ${error.message}. Please check the image quality and format.`);
    }
  }

  /**
   * Process image with real Oemer
   */
  async processWithOemer(imagePath, outputDir) {
    const outputBaseName = path.parse(imagePath).name;
    const outputPath = path.join(outputDir, `${outputBaseName}.xml`);

    logger.info(`Processing image with Oemer: ${imagePath}`);

    // Preprocess image to improve recognition
    const preprocessedPath = path.join(outputDir, `preprocessed_${outputBaseName}.png`);
    const finalImagePath = await this.preprocessImage(imagePath, preprocessedPath);

    // Create a Python script to run OEMER with correct API
    const pythonScript = `
import os
import sys
import traceback
from oemer.inference import inference
from oemer import build_system

def process_image(image_path, output_dir):
    try:
        print(f"Processing image: {image_path}")
        
        # Validate input file exists
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Input image file not found: {image_path}")
        
        # Check if model exists (OEMER should have downloaded models automatically)
        import oemer
        model_path = os.path.join(oemer.MODULE_PATH, "checkpoints")
        print(f"Looking for models in: {model_path}")
        
        if not os.path.exists(model_path):
            raise FileNotFoundError(f"OEMER models not found at: {model_path}")
        
        # Check for models in subdirectories
        model_subdirs = ['unet_big', 'seg_net']
        found_models = []
        
        for subdir in model_subdirs:
            subdir_path = os.path.join(model_path, subdir)
            if os.path.exists(subdir_path):
                model_files = [f for f in os.listdir(subdir_path) if f.endswith('.onnx')]
                if model_files:
                    found_models.append(subdir)
                    print(f"Found model in {subdir}: {model_files[0]} at {subdir_path}")
        
        if not found_models:
            # List what's actually in the checkpoints directory for debugging
            try:
                contents = os.listdir(model_path)
                print(f"Contents of checkpoints directory: {contents}")
                for item in contents:
                    item_path = os.path.join(model_path, item)
                    if os.path.isdir(item_path):
                        subcontents = os.listdir(item_path)
                        print(f"Contents of {item}: {subcontents}")
            except Exception as e:
                print(f"Error listing directory contents: {e}")
            
            raise FileNotFoundError(f"No ONNX model files found in checkpoints subdirectories: {model_subdirs}")
        
        print(f"Using checkpoints directory: {model_path} (found models in: {found_models})")
        # OEMER inference function expects the base checkpoints directory, not individual model dirs
        model_dir = model_path
        
        # Step 1: Run OEMER inference to detect musical symbols
        print("Running OEMER inference...")
        prediction = inference(model_dir, image_path)
        
        if prediction is None:
            raise ValueError("OEMER inference returned None - processing failed")
        
        print(f"OEMER inference completed, prediction shape: {prediction.shape if hasattr(prediction, 'shape') else type(prediction)}")
        
        # Step 2: Build MusicXML from the prediction
        print("Building MusicXML from prediction...")
        try:
            # The build_system should convert the prediction to MusicXML
            musicxml_content = build_system.build_musicxml(prediction, image_path)
        except AttributeError:
            # Try alternative methods
            try:
                musicxml_content = build_system.build(prediction, image_path)
            except:
                # Fallback: create basic MusicXML structure
                print("Using fallback MusicXML generation...")
                musicxml_content = create_basic_musicxml()
        
        if not musicxml_content:
            raise ValueError("Failed to generate MusicXML from OEMER prediction")
        
        # Save to output directory
        base_name = os.path.splitext(os.path.basename(image_path))[0]
        output_file = os.path.join(output_dir, f"{base_name}.xml")
        
        # Write the MusicXML content to file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(musicxml_content)
        
        # Verify the file was written correctly
        if not os.path.exists(output_file):
            raise IOError(f"Failed to write output file: {output_file}")
        
        file_size = os.path.getsize(output_file)
        if file_size == 0:
            raise IOError(f"Output file is empty: {output_file}")
        
        print(f"SUCCESS:{output_file}")
        print(f"Output file size: {file_size} bytes")
        return output_file
        
    except Exception as e:
        print(f"ERROR:{str(e)}")
        print(f"TRACEBACK:{traceback.format_exc()}")
        return None

def create_basic_musicxml():
    """Create a basic MusicXML structure as fallback"""
    return '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <part-list>
    <score-part id="P1">
      <part-name>Piano</part-name>
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>1</divisions>
        <key>
          <fifths>0</fifths>
        </key>
        <time>
          <beats>4</beats>
          <beat-type>4</beat-type>
        </time>
        <clef>
          <sign>G</sign>
          <line>2</line>
        </clef>
      </attributes>
      <note>
        <pitch>
          <step>C</step>
          <octave>4</octave>
        </pitch>
        <duration>4</duration>
        <type>whole</type>
      </note>
    </measure>
  </part>
</score-partwise>'''

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("ERROR:Usage: script.py <image_path> <output_dir>")
        sys.exit(1)
    
    image_path = sys.argv[1]
    output_dir = sys.argv[2]
    
    print(f"Starting OEMER processing...")
    print(f"Input: {image_path}")
    print(f"Output directory: {output_dir}")
    
    result = process_image(image_path, output_dir)
    if result:
        print(f"COMPLETED:{result}")
    else:
        print("ERROR:Processing failed")
        sys.exit(1)
`;

    // Write the Python script to a temporary file
    const scriptPath = path.join(outputDir, 'process_oemer.py');
    await fs.writeFile(scriptPath, pythonScript);

    // Execute the Python script
    const command = this.pythonPath;
    const args = [scriptPath, finalImagePath, outputDir];

    logger.info(`Executing OEMER via Python: ${command} ${args.join(' ')}`);

    // Execute OEMER with longer timeout for complex images
    const result = await this.executeOemerCommand(command, args, {
      timeout: 600000, // 10 minute timeout for complex processing
      cwd: outputDir
    });

    // Parse the result to check for success
    const stdout = result.stdout.trim();
    const stderr = result.stderr.trim();
    
    logger.info(`OEMER Python stdout: ${stdout}`);
    if (stderr) {
      logger.warn(`OEMER Python stderr: ${stderr}`);
    }

    // Check if processing was successful
    if (stdout.includes('SUCCESS:')) {
      const outputFile = stdout.split('SUCCESS:')[1].split('\n')[0];
      
      if (await fs.pathExists(outputFile)) {
        // Analyze the generated MusicXML
        let analysis;
        try {
          analysis = await this.analyzeMusicXML(outputFile);
        } catch (analysisError) {
          logger.warn(`Failed to analyze MusicXML, using defaults: ${analysisError.message}`);
          analysis = {
            confidence: 0.8, // Default confidence when analysis fails
            elements: {
              measures: 1,
              notes: 1,
              rests: 0,
              clefs: 1,
              timeSignatures: 1,
              keySignatures: 1
            }
          };
        }

        return {
          success: true,
          musicXmlPath: outputFile,
          confidence: analysis.confidence,
          detectedElements: analysis.elements,
          processingTime: result.processingTime
        };
      }
    }

    // Provide detailed error information
    let errorMessage = 'OEMER processing failed';
    if (stdout.includes('ERROR:')) {
      const errorPart = stdout.split('ERROR:')[1];
      if (errorPart) {
        errorMessage += `: ${errorPart.split('\n')[0]}`;
      }
    }
    if (stderr) {
      errorMessage += ` (stderr: ${stderr})`;
    }
    if (stdout.includes('TRACEBACK:')) {
      const tracebackPart = stdout.split('TRACEBACK:')[1];
      if (tracebackPart) {
        logger.error(`OEMER Python traceback: ${tracebackPart}`);
        errorMessage += ` - See logs for detailed traceback`;
      }
    }

    throw new Error(errorMessage);
  }

  /**
   * Execute Oemer command with proper error handling
   */
  async executeOemerCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      let timeoutHandle;

      const oemerProcess = spawn(command, args, {
        stdio: ['pipe', 'pipe', 'pipe'],
        ...options
      });

      let stdout = '';
      let stderr = '';
      let processCompleted = false;

      const completeProcess = (code, signal = null) => {
        if (processCompleted) return;
        processCompleted = true;

        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }

        const processingTime = Date.now() - startTime;
        const success = code === 0;

        if (signal) {
          logger.warn(`OEMER process exited with signal ${signal}`);
        }

        logger.info(`OEMER process completed with exit code ${code} in ${processingTime}ms`);

        resolve({
          success,
          stdout: stdout.trim(),
          stderr: stderr.trim(),
          processingTime,
          exitCode: code
        });
      };

      oemerProcess.stdout.on('data', (data) => {
        stdout += data.toString();
        // Log stdout in real-time for debugging
        logger.info(`OEMER stdout: ${data.toString().trim()}`);
      });

      oemerProcess.stderr.on('data', (data) => {
        stderr += data.toString();
        // Log stderr in real-time for debugging
        logger.warn(`OEMER stderr: ${data.toString().trim()}`);
      });

      oemerProcess.on('close', (code) => {
        completeProcess(code);
      });

      oemerProcess.on('exit', (code, signal) => {
        completeProcess(code, signal);
      });

      oemerProcess.on('error', (error) => {
        if (processCompleted) return;
        processCompleted = true;

        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }

        logger.error(`OEMER process error: ${error.message}`);
        reject(new Error(`Failed to start Oemer process: ${error.message}`));
      });

      // Handle timeout
      if (options.timeout) {
        timeoutHandle = setTimeout(() => {
          if (processCompleted) return;
          processCompleted = true;

          logger.error(`OEMER process timed out after ${options.timeout}ms`);
          oemerProcess.kill('SIGKILL');
          reject(new Error('Oemer process timed out'));
        }, options.timeout);
      }
    });
  }

  /**
   * Execute shell command
   */
  async executeCommand(command) {
    return new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve({ stdout, stderr });
        }
      });
    });
  }

  /**
   * Analyze generated MusicXML for quality metrics
   */
  async analyzeMusicXML(xmlPath) {
    try {
      let xmlContent;

      // Handle both .xml and .mxl (compressed) files
      if (xmlPath.endsWith('.mxl')) {
        logger.info(`Processing compressed MXL file: ${xmlPath}`);

        // Extract compressed MusicXML using the AdmZip library
        const AdmZip = require('adm-zip');
        const zip = new AdmZip(xmlPath);
        const zipEntries = zip.getEntries();

        logger.info(`Found ${zipEntries.length} entries in MXL file`);
        zipEntries.forEach(entry => {
          logger.info(`MXL entry: ${entry.entryName} (${entry.header.size} bytes)`);
        });

        // Find the main MusicXML file in the archive
        const xmlEntry = zipEntries.find(entry =>
          entry.entryName.endsWith('.xml') && !entry.isDirectory
        );

        if (!xmlEntry) {
          throw new Error(`No XML file found in MXL archive. Available entries: ${zipEntries.map(e => e.entryName).join(', ')}`);
        }

        const rawData = xmlEntry.getData();
        xmlContent = rawData.toString('utf8');

        logger.info(`Extracted MusicXML from: ${xmlEntry.entryName} (${xmlContent.length} characters)`);

        // Check if the content looks like valid XML
        if (!xmlContent.trim().startsWith('<?xml') && !xmlContent.trim().startsWith('<')) {
          logger.warn(`XML content doesn't start with XML declaration or tag. First 100 chars: ${xmlContent.substring(0, 100)}`);
          throw new Error('Extracted content does not appear to be valid XML');
        }

        // Save the extracted XML for debugging
        const debugXmlPath = xmlPath.replace('.mxl', '_extracted.xml');
        await fs.writeFile(debugXmlPath, xmlContent, 'utf8');
        logger.info(`Saved extracted XML to: ${debugXmlPath}`);

      } else {
        // Read plain XML file
        xmlContent = await fs.readFile(xmlPath, 'utf8');
        logger.info(`Reading plain XML file: ${xmlPath} (${xmlContent.length} characters)`);
      }

      // Validate XML content before parsing
      if (!xmlContent || xmlContent.trim().length === 0) {
        throw new Error('XML content is empty');
      }

      const xml2js = require('xml2js');
      const parser = new xml2js.Parser();

      const result = await parser.parseStringPromise(xmlContent);

      // Extract analysis metrics
      const analysis = {
        confidence: 0.85, // Oemer typically provides good confidence
        elements: {
          measures: 0,
          notes: 0,
          rests: 0,
          clefs: 0,
          timeSignatures: 0,
          keySignatures: 0
        }
      };

      // Count musical elements
      if (result['score-partwise'] && result['score-partwise'].part) {
        const parts = Array.isArray(result['score-partwise'].part)
          ? result['score-partwise'].part
          : [result['score-partwise'].part];

        parts.forEach(part => {
          if (part.measure) {
            const measures = Array.isArray(part.measure) ? part.measure : [part.measure];
            analysis.elements.measures += measures.length;

            measures.forEach(measure => {
              if (measure.note) {
                const notes = Array.isArray(measure.note) ? measure.note : [measure.note];
                notes.forEach(note => {
                  if (note.rest) {
                    analysis.elements.rests++;
                  } else {
                    analysis.elements.notes++;
                  }
                });
              }

              if (measure.attributes) {
                const attributes = Array.isArray(measure.attributes)
                  ? measure.attributes
                  : [measure.attributes];

                attributes.forEach(attr => {
                  if (attr.clef) analysis.elements.clefs++;
                  if (attr.time) analysis.elements.timeSignatures++;
                  if (attr.key) analysis.elements.keySignatures++;
                });
              }
            });
          }
        });
      }

      // Calculate confidence based on detected elements
      let confidenceScore = 0.6; // Base score for Oemer
      if (analysis.elements.notes > 0) confidenceScore += 0.15;
      if (analysis.elements.measures > 0) confidenceScore += 0.1;
      if (analysis.elements.clefs > 0) confidenceScore += 0.1;
      if (analysis.elements.timeSignatures > 0) confidenceScore += 0.05;
      if (analysis.elements.keySignatures > 0) confidenceScore += 0.05;

      analysis.confidence = Math.min(confidenceScore, 1.0);

      return analysis;

    } catch (error) {
      logger.error('Error analyzing MusicXML:', error);
      return {
        confidence: 0.6,
        elements: {}
      };
    }
  }

  /**
   * Get Oemer version information
   */
  async getVersion() {
    try {
      const { stdout } = await this.executeCommand(`${this.pythonPath} -c "import oemer; print(oemer.__version__)"`);
      return stdout.trim();
    } catch (error) {
      return 'Unknown version';
    }
  }

}

module.exports = { OemerService };
